\documentclass[11pt, a4paper, spanish, openright, twoside]{book}
\usepackage[spanish, activeacute]{babel}
\usepackage[utf8]{inputenc}
\usepackage[top=2.5cm, bottom=2.5cm, outer=1.75cm, inner=1.75cm, heightrounded, marginparwidth=2.5cm, marginparsep=0.3cm]{geometry}	%márgenes empequeñecidos
%\usepackage[top=2.5cm, bottom=2.25cm, outer=2.75cm, inner=2.75cm, heightrounded, marginparwidth=2.5cm, marginparsep=0.3cm]{geometry}	%márgenes originalmente
\usepackage{dpg}
\usepackage{afvc}
%Figuras
\usepackage[vflt]{floatflt}		%Entorno float-figure
%\graphicspath{/Temas/Tema01/Imagenes}

%%%%%%		chapter's style		%%%%%%%%%%%%%%%%%%%

\renewcommand{\thepage}{\arabic{page}}% Arabic page numbers\fancyhead{}
\pagestyle{fancy}
\fancyfoot{}
\fancyhead[RO]{}	%encabezado de pares: nombre de la sección
\fancyfoot[LE,RO]{\thepage}	%abajo a izqda en pares, derecha en impares: numero de pagina
\fancyhead[LE]{\nouppercase{\leftmark}} %cuadro izquierdo de pagina par: parte y contador
\fancyfoot[CE]{Tecnología y Organización de Computadores} 
\fancyfoot[CO]{Doble Grado Informática-Matemáticas - Universidad Complutense}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\headrulewidth}{0.4pt}		% linea por debajo del encabezado
\renewcommand{\sectionmark}[1]{\markright{\textbf{\thesection. #1}}}	%negrita
\renewcommand{\labelitemi}{$\circ$} %Primer itemize con circunferencia vacia
\renewcommand{\labelitemii}{$\cdot$} %Segundo itemize con punto pequeño
\renewcommand*{\thesection}{\arabic{section}}	% Hace que no apareca el indice de capitulos y que comience en section, GRACIAS A RUBEN
\setlength{\leftmarginii}{0em} %Segundo itemize sin sangria
\setlength{\leftmarginiii}{1em} %Tercer itemize casi sin sangria
\renewcommand{\labelitemiii}{ }
\pagenumbering{roman}
\newcommand*{\PKT}{\hbox{P}\kern-2.5pt\lower3.5pt\hbox{\small{K}}\kern-2.8pt\hbox{T}\kern-2pt}	%PiKey Team en bonito


\begin{document} 
\title{\Huge{\textsc{Proyecto -\\
	Qué hemos hecho}} \\
	\vspace{0.7cm}
	 \textsc{\Large{Tecnología y Organización de Computadores}} \\
	\includegraphics[scale=0.3]{ucm.pdf}}
\author{{\Large{PiKey Team-}} \PKT \ : \vspace{0.2cm} \\
	Jesús Aguirre Pemán \\
	 Enrique Ballesteros Horcajo \\
	 Mayra Alexandra Castrosqui Florián\\
	 Jaime Dan Porras Rhee \\
	 Ignacio Iker Prado Rujas}
\date{\Today}
\maketitle

\newpage
\mbox{}
\thispagestyle{empty}						% Hoja en blanco, sin numeros ni nada
\newpage


\tableofcontents 							%INDICE hipervinculado

\newpage
\mbox{}
\thispagestyle{empty}						% Hoja en blanco, sin numeros ni nada
\newpage

\pagenumbering{arabic}						% Pone el contador de paginas a 1 y ahora en numeros normales

\vspace{3cm}

%ESTE FICHERO DEBERÍA SER DE UNAS 10-15 CARAS APROX.____________________________________________________

\section{Ruta de datos}


\section{Controlador/es (y máquinas de estados)}
En primer lugar, vemos que cargamos separadamente de memoria a Barry,  los mapas, los obstáculos, las monedas y el cartel de "Game Over". Por tanto, necesitaremos 5 memorias ROM diferentes.

En primer lugar, describamos el código referente a los movimientos:
Las señales $posy$ y $posx$ nos indican en qué posición estamos pintandolos obstáculos, y su concatenación, $dir_mem$, es la dirección eque utilizaremos para leer de memoria. Lo mismo ocurre con el fondo, barry, y "Game Over".

Para cuadrar en la pantalla lo que leemos de memoria bla bla bla (aquí metería una imagen de la hoja esa de Iker que usamos siempre)

El process $mueve_obstaculos$ es el encargado de refrescar la pantalla y pintar los obstáculos que salen a medida que avanzamos en el juego. Para ello borra la primera columna, desplaza el resto de columnas a la izquierda, e inserta la nueva columna a la derecha. El process $mueve_fondo$ hace lo mismo con el fondo de la pantalla.

$mueve_munyeco$ se ocupa de dar la sensación de movimiento a Barry: cuando esté en el suelo, se cargarán alternativamente dos imágenes diferentes para que parezca que sus piernas se mueven.
$mov_munyeco$ actualiza la posición de Barry en función de su estado, y $mueve_munyeco$ actualiza el estado del muñeco en función del estado anterior y la entrada de teclado (máquina de de estados). Junto con $estado_munyeco$ son los encargados de actualizar estado y posición de Barry.

El juego tendrá 4 estados:
\begin{itemize}
\item Game Over: Nos hemos chocado, y por tanto, la partida se ha acabado.
\item Pause: Pulsando la tecla 'p' paramos el juego.
\item Quieto: Barry no está subiendo ni bajando: puede estar andando o en el techo.
\item Subiendo: Al pulsar la barra espaciadora activamos los propulsores del Jetpack y Barry sube.
\item Bajando: Cuando soltamos la barra espaciadora, cortamos el combustible y Barry cae.
 \end{itemize}


$niveles$ se encarga del paso entre los diferentes niveles: al aguantar sin chocarnos cierta cantidad de tiempo en un nivel pasamos al siguiente, para lo que hay que cambiar obstáculos y fondo.

$controla_juego$ es el encargado de parar y reanudar el juego, así como de terminar la partida cuando nos choquemos.

... cosas de choques... mejor que lo haga iker

El process $pinta_obstaculos$ lee la ROM de obstáculos y los pinta en la pantalla. En los píxeles donde no haya obstáculos se pintará el fondo del juego. $pinta_munyeco$ hace lo mismo con la ROM de Barry, pintándolo en las posiciones de la pantalla que indica $r_my$, la variable que almacena la posición del protagonista.

Similar es $pinta_game_over$, que además comprobará el estado del juego para cerciorarse de que nos hemos chocado antes de dibujar el "Game Over".

$pinta_bordes$ dibuja los bordes de la pantalla del juego.

Finalmente, $colorear$ decide qué pintamos en cada píxel, eligiendo entre.
\begin{itemize}
\item Bordes
\item Game Over
\item Barry
\item Obstáculos
\item Fondo
\end{itemize}

\section{Somos los mejores (venderse)}
En serio hay alguna duda?

Hemos conseguido reproducir fidedignamente el videojuego $Jetpack Joyride$, incluyendo varios niveles diferentes, posibilidad de recoger monedas (y contar cuántas hemos recogido)...

Orgullosos de algo en particular...

Por qué ha sido bueno ser 5...
Formar un equipo de 5 personas ha sido clave para el éxito de nuestro proyecto, puesto que nos ha permitido trabajar en paralelo en un mínimo de 3 tareas simultáneas. 

\section{Qué y por qué no funciona}
Funciona todo porque somos los mejores (ver apartado 3)



\section{Bibliografía}
Reutilización de código
Ha sido de gran utilidad el software de la Universidad Carlos III que permite pasar una imagen en formato PPM (Portable Pixel Map) a ROM. Esto ha posibilitado la carga de mapas muy realistas y que aprovechan al máximo la capacidad de la FPGA (petaqueo excesivo).
Precisamente este fue uno de los principales problemas que encontramos al inicio de nuestro proyecto, y esta herramienta permitió solucionarlo de manera elegante y funcional (más petaqueo)
\section{Trabajo individual}
La organización orientativa del trabajo ha sido la sguiente:
\begin{itemize}
\item Jaime y Mayra: controlador de teclado, gestión y diseño de mapas, cambio de niveles, movimiento de barry.
\item Jesús: Imágenes, memorias ROM, monedas.
\item Iker: Barry, choques, monedas
\item Quique: Ser Führer del proyecto, pantalla principal, movimiento de Barry y de los mapas, monedas.
\end{itemize}
No obstante, al ser cinco integrantes en el proyecto, hemos podido variar la distribución de tareas en función de los requerimientos en cada fase del proceso. 


\end{document}