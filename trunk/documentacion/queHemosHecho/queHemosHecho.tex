\documentclass[11pt, a4paper, spanish, openright, twoside]{book}
\usepackage[spanish, activeacute]{babel}
\usepackage[utf8]{inputenc}
\usepackage[top=2.5cm, bottom=2.5cm, outer=1.75cm, inner=1.75cm, heightrounded, marginparwidth=2.5cm, marginparsep=0.3cm]{geometry}	%márgenes empequeñecidos
%\usepackage[top=2.5cm, bottom=2.25cm, outer=2.75cm, inner=2.75cm, heightrounded, marginparwidth=2.5cm, marginparsep=0.3cm]{geometry}	%márgenes originalmente
\usepackage{dpg}
\usepackage{afvc}
%Figuras
\usepackage[vflt]{floatflt}		%Entorno float-figure
%\graphicspath{/Temas/Tema01/Imagenes}

%%%%%%		chapter's style		%%%%%%%%%%%%%%%%%%%

\renewcommand{\thepage}{\arabic{page}}% Arabic page numbers\fancyhead{}
\pagestyle{fancy}
\fancyfoot{}
\fancyhead[RO]{}	%encabezado de pares: nombre de la sección
\fancyfoot[LE,RO]{\thepage}	%abajo a izqda en pares, derecha en impares: numero de pagina
\fancyhead[LE]{\nouppercase{\leftmark}} %cuadro izquierdo de pagina par: parte y contador
\fancyfoot[CE]{Tecnología y Organización de Computadores} 
\fancyfoot[CO]{Doble Grado Informática-Matemáticas - Universidad Complutense}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\headrulewidth}{0.4pt}		% linea por debajo del encabezado
\renewcommand{\sectionmark}[1]{\markright{\textbf{\thesection. #1}}}	%negrita
\renewcommand{\labelitemi}{$\circ$} %Primer itemize con circunferencia vacia
\renewcommand{\labelitemii}{$\cdot$} %Segundo itemize con punto pequeño
\renewcommand*{\thesection}{\arabic{section}}	% Hace que no apareca el indice de capitulos y que comience en section, GRACIAS A RUBEN
\setlength{\leftmarginii}{0em} %Segundo itemize sin sangria
\setlength{\leftmarginiii}{1em} %Tercer itemize casi sin sangria
\renewcommand{\labelitemiii}{ }
\pagenumbering{roman}
\newcommand*{\PKT}{\hbox{P}\kern-2.5pt\lower3.5pt\hbox{\small{K}}\kern-2.8pt\hbox{T}\kern-2pt}	%PiKey Team en bonito


\begin{document} 
\title{\Huge{\textsc{Proyecto -\\
	Qué hemos hecho}} \\
	\vspace{0.7cm}
	 \textsc{\Large{Tecnología y Organización de Computadores}} \\
	\includegraphics[scale=0.3]{ucm.pdf}}
\author{{\Large{PiKey Team-}} \PKT \ : \vspace{0.2cm} \\
	Jesús Aguirre Pemán \\
	 Enrique Ballesteros Horcajo \\
	 Mayra Alexandra Castrosqui Florián\\
	 Jaime Dan Porras Rhee \\
	 Ignacio Iker Prado Rujas}
\date{\Today}
\maketitle

\newpage
\mbox{}
\thispagestyle{empty}						% Hoja en blanco, sin numeros ni nada
\newpage


\tableofcontents 							%INDICE hipervinculado

\newpage
\mbox{}
\thispagestyle{empty}						% Hoja en blanco, sin numeros ni nada
\newpage

\pagenumbering{arabic}						% Pone el contador de paginas a 1 y ahora en numeros normales

\vspace{3cm}

%ESTE FICHERO DEBERÍA SER DE UNAS 10-15 CARAS APROX.____________________________________________________

\section{Ruta de datos}
Se cuenta con dos dispositivos de entrada: el teclado y el reset, y con dos de salida: la pantalla y el display LED de 7 segmentos. 
Las únicas teclas reconocidas por el teclado son la barra espaciadora y la tecla $P$. El controlador del teclado detecta dichas teclas y activa las señales \texttt{pulsado} y \texttt{pausado} que son las que se encargan de la lógica del movimiento de Barry y del fondo. 

\section{Controlador/es (y máquinas de estados)}
En primer lugar, vemos que cargamos separadamente de memoria a Barry,  los mapas, los obstáculos y el cartel de ``Game Over". Por tanto, necesitaremos 5 memorias ROM diferentes. Para mostrar a Barry corriendo tenemos dos ROM, y a esto hay que sumarle las tres ROM de fondos junto a las 3 ROM de obstáculos, haciendo un total de 9 ROMs, cada una del tamaño correspondiente. 

A continuación, describamos el código referente a los movimientos:
Las señales $posy$ y $posx$ nos indican en qué posición estamos pintandolos obstáculos, y su concatenación, $dir\_mem$, es la dirección que utilizaremos para leer de memoria. Lo mismo ocurre con el fondo, barry, y ``Game Over".

Para cuadrar en la pantalla lo que leemos de memoria bla bla bla (aquí metería una imagen de la hoja esa de Iker que usamos siempre)

El process $mueve\_obstaculos$ es el encargado de refrescar la pantalla y pintar los obstáculos que salen a medida que avanzamos en el juego. Para ello borra la primera columna, desplaza el resto de columnas a la izquierda, e inserta la nueva columna a la derecha. El process $mueve\_fondo$ hace lo mismo con el fondo de la pantalla.

$mueve\_munyeco$ se ocupa de dar la sensación de movimiento a Barry: cuando esté en el suelo, se cargarán alternativamente dos imágenes diferentes para que parezca que sus piernas se mueven.
$mov\_munyeco$ actualiza la posición de Barry en función de su estado, y $mueve\_munyeco$ actualiza el estado del muñeco en función del estado anterior y la entrada de teclado (máquina de de estados). Junto con $estado\_munyeco$ son los encargados de actualizar estado y posición de Barry.

El juego tendrá 4 estados:
\begin{itemize}
\item Game Over: Nos hemos chocado, y por tanto, la partida se ha acabado.
\item Pause: Pulsando la tecla `p'  \ paramos el juego.
\item Quieto: Barry no está subiendo ni bajando: puede estar andando o en el techo.
\item Subiendo: Al pulsar la barra espaciadora activamos los propulsores del Jetpack y Barry sube.
\item Bajando: Cuando soltamos la barra espaciadora, cortamos el combustible y Barry cae.
 \end{itemize}


$niveles$ se encarga del paso entre los diferentes niveles: al aguantar sin chocarnos cierta cantidad de tiempo en un nivel pasamos al siguiente, para lo que hay que cambiar obstáculos y fondo.
Hay tres estados en los niveles:
\begin{itemize}
\item \texttt{Nivel1}: en este nivel se cargan el fondo de laboratorio y los obstáculos de trampas eléctricas. Una vez se hayan conseguido $5$ ó  $5+15n<60,\ n\in\mathbb{N}$  monedas se pasará al \texttt{nivel 2}, y se activará la señal $bloquea\_obstaculo$ que evita que los obstáculos del nivel siguiente se activen de golpe, a través del \texttt{gestorCambioNivel} que hace que los obstáculos se cambien gradualmente. 
\item \texttt{Nivel2: }en este nivel se cargan el fondo de laboratorio y los obstáculos de tuberías. Al conseguir  $10+15n<60,\ n\in\mathbb{N}$ monedas se pasará al \texttt{nivel3}, activando a su vez $bloquea\_obstáculos$.
\item \texttt{Nivel3: }en este nivel se cargan el fondo con nubes y montañas y los obstáculos de bolas de fuego. Al conseguir $15n<60,\ n\in\mathbb{N}$ monedas se pasará al nivel 1, y una vez se haya llegado a las 60 no se cambiará de nivel, aunque el juego continuará. 
\end{itemize}

$controla\_juego$ es el encargado de parar y reanudar el juego, así como de terminar la partida cuando nos choquemos.

... cosas de choques... mejor que lo haga iker

El process $pinta\_obstaculos$ lee la ROM de obstáculos y los pinta en la pantalla. En los píxeles donde no haya obstáculos se pintará el fondo del juego. $pinta\_munyeco$ hace lo mismo con la ROM de Barry, pintándolo en las posiciones de la pantalla que indica $r\_my$, la variable que almacena la posición del protagonista.

Similar es $pinta\_game\_over$, que además comprobará el estado del juego para cerciorarse de que nos hemos chocado antes de dibujar el ``Game Over".

$pinta\_bordes$ dibuja los bordes de la pantalla del juego.

Finalmente, $colorear$ decide qué pintamos en cada píxel, eligiendo entre.
\begin{itemize}
\item Bordes
\item Game Over
\item Barry
\item Obstáculos
\item Fondo
\end{itemize}

\section{Somos los mejores (venderse)}
Jesús:  Tras decidir el proyecto, lo primero fue conseguir pintar imágenes en pantalla. Dibujarlas mediante process fue fácil, pero el nivel de complejidad de los dibujos era muy bajo. Tras estudiar diferentes opciones finalmente se decidió cargarlas desde ROM.
El problema ahora era generar la ROM.

Para imágenes pequeñas, como podía ser el caso de la imagen de Barry, se puede escribir manualmente el valor de cada pixel de la ROM. Sin embargo, para cargar los mapas era virtualmente imposible. La solución estaba clara: mediante un programa generar la ROM automáticamente. Afortunadamente, tras investigar a fondo sobre las memorias ROM y su uso en códigos VHDL, conseguimos encontrar un programa, hecho por la Universidad Rey Juan Carlos, que convertía las imágenes en PPM a ROM

Una vez solventado ese problema, había que darle movimiento a los mapas, lo cual avanzó enormemente el apartado visual del proyecto.

No obstante, este juego no tendría sentido sin obstáculos de por medio con los que chocarse.
Este fue uno de los grandes escollos del proyecto: detectar el choque.
Finalmente, decidimos pintar los obstáculos de un color determinado para comprobar si Barry ocupaba el mismo píxel que el obstáculo y dar por finalizada la partida.

Una vez decidida la estrategia llegaba el momento de implementarla, cosa que fue bastante más complicada de lo esperado, y que finalmente Iker resolvió elegantemente con una comprobación constante circular del perímetro exterior de la imagen de Barry.
Ahora teníamos choques y movimiento de los mapas, y faltaba darle un objetivo al juego: conseguir el máximo número posible de monedas.

Para ello teníamos que pintarlas, chocarnos con ellas, y borrarlas de la pantalla tras el choque, además de mostrar por el display 7 segmentos el número de monedas acumuladas.

Detectar el choque ya sabíamos cómo, pero eliminar la moneda y aumentar el contador se tornó más difícil de lo que parecía, puesto que había que realizar una gran distinción de casos según el estado de la moneda (subiendo, bajando, quieta, invisible...). Además, una vez chocara con Barry había que borrarla de la pantalla hasta que volviera a aparecer metros más adelante en el mapa. El hecho de que la moneda se moviera y no estuviese quieta en el mapa complicó la implementación pero dotó al juego de un aspecto visual mucho más desarrollado.

Global:
En serio hay alguna duda?

Hemos conseguido reproducir fidedignamente el videojuego $Jetpack Joyride$, incluyendo varios niveles diferentes, posibilidad de recoger monedas (y contar cuántas hemos recogido)...

Orgullosos de algo en particular...

Por qué ha sido bueno ser 5...
Formar un equipo de 5 personas ha sido clave para el éxito de nuestro proyecto, puesto que nos ha permitido trabajar en paralelo en un mínimo de 3 tareas simultáneas. 

\section{Qué y por qué no funciona}
Funciona todo porque somos los mejores (ver apartado 3). Sin embargo, otros añadidos si hubiésemos dispuesto de más tiempo podrían ser:
\begin{itemize}
\item Menú principal.
\item Posibilidad de elegir personaje.
\item Vehículos utilizables al almacenar un número determinado de monedas. En este caso, los mapas cambiarían pasado un tiempo en lugar de cada 5 monedas recogidas.
\item Mejorar la  manejabilidad del personaje para que acelerase al subir y flotase al comienzo de la bajada. Este apartado se intentó implementar pero fue descartado puesto que el tiempo que requería no era consonante con la mejora del juego con su añadido.
\item Contador de número de metros recorridos. Este apartado también fue considerado y comenzado, pero requería un tiempo del que no disponíamos.
\end{itemize}


\section{Bibliografía}
Reutilización de código:

Ha sido de gran utilidad el software de la Universidad Carlos III que permite pasar una imagen en formato PPM (Portable Pixel Map) a ROM. Esto ha posibilitado la carga de mapas muy realistas y que aprovechan al máximo la capacidad de la FPGA (petaqueo excesivo).
Precisamente este fue uno de los principales problemas que encontramos al inicio de nuestro proyecto, y esta herramienta permitió solucionarlo de manera elegante y funcional. 

El proceso para convertir una imagen cualquiera a una ROM es el siguiente:
\begin{enumerate}
\item Convertimos la imagen a formato PPM mediante un programa de edición de imágenes (por ejemplo IrfanView).
\item Desde línea de comandos, ejecutamos la aplicacion $ppm2rom$ seguida de los parámetros 9(bits por cada pixel) y 1 (número de memorias ROM).
\item Conectamos la ROM al módulo principal del proyecto, y ya podemos mostrar la imagen por pantalla.
\end{enumerate}

\section{Trabajo individual}
La organización orientativa del trabajo ha sido la sguiente:
\begin{itemize}
\item Jaime y Mayra: controlador de teclado, gestión y diseño de mapas, cambio de niveles, movimiento de Barry.
\item Jesús: Imágenes, memorias ROM, monedas.
\item Iker: Barry, choques, monedas.
\item Quique: Coordinar el proyecto, pantalla principal, movimiento de Barry y de los mapas, monedas.
\end{itemize}
No obstante, al ser cinco integrantes en el proyecto, hemos podido variar la distribución de tareas en función de los requerimientos en cada fase del proceso. 


\end{document}